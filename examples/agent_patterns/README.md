# 一般的なエージェントパターン / Common agentic patterns

このフォルダには、エージェントの一般的なパターンの例が含まれています。

## 決定論的フロー / Deterministic flows

一般的な戦術は、タスクを一連の小さなステップに分解することです。各タスクはエージェントによって実行され、あるエージェントの出力が次のエージェントの入力として使用されます。例えば、ストーリーを生成するタスクであれば、以下のステップに分解できます：

1. アウトラインを生成する
2. ストーリー本文を生成する
3. エンディングを生成する

これらの各ステップはエージェントによって実行できます。あるエージェントの出力が次のエージェントの入力として使用されます。

この例については、[`deterministic.py`](./deterministic.py)ファイルを参照してください。

## ハンドオフとルーティング / Handoffs and routing

多くの状況では、特定のタスクを処理する専門のサブエージェントがあります。ハンドオフを使用して、タスクを適切なエージェントにルーティングできます。

例えば、フロントラインエージェントがリクエストを受け取り、リクエストの言語に基づいて専門のエージェントにハンドオフするといったことが考えられます。
この例については、[`routing.py`](./routing.py)ファイルを参照してください。

## ツールとしてのエージェント / Agents as tools

ハンドオフの考え方は、新しいエージェントが「引き継ぐ」というものです。新しいエージェントは以前の会話履歴を見て、その時点から会話を所有します。しかし、これがエージェントを使用する唯一の方法ではありません。エージェントをツールとして使用することもできます - ツールエージェントは独自に実行され、結果を元のエージェントに返します。

例えば、上記の翻訳タスクをツール呼び出しとしてモデル化することもできます：言語固有のエージェントに引き継ぐのではなく、エージェントをツールとして呼び出し、その結果を次のステップで使用することができます。これにより、複数の言語を一度に翻訳するなどが可能になります。

この例については、[`agents_as_tools.py`](./agents_as_tools.py)ファイルを参照してください。

## 判断者としてのLLM / LLM-as-a-judge

LLMは、フィードバックを与えられると出力の品質を向上させることができます。一般的なパターンは、モデルを使用して応答を生成し、次に2番目のモデルを使用してフィードバックを提供することです。コストを最適化するために、初期生成には小さなモデルを使用し、フィードバックには大きなモデルを使用することもできます。

例えば、LLMを使用してストーリーのアウトラインを生成し、次に2番目のLLMを使用してアウトラインを評価し、フィードバックを提供することができます。そのフィードバックを使用してアウトラインを改善し、LLMが満足するまで繰り返すことができます。

この例については、[`llm_as_a_judge.py`](./llm_as_a_judge.py)ファイルを参照してください。

## 並列処理 / Parallelization

複数のエージェントを並列に実行することは一般的なパターンです。これは、レイテンシ（例：互いに依存しない複数のステップがある場合）や、複数の応答を生成して最良のものを選ぶなど、他の理由にも役立ちます。

この例については、[`parallelization.py`](./parallelization.py)ファイルを参照してください。これは翻訳エージェントを並列に複数回実行し、最良の翻訳を選択します。

## ガードレール / Guardrails

並列処理に関連して、エージェントへの入力が有効であることを確認するために入力ガードレールを実行したい場合がよくあります。例えば、カスタマーサポートエージェントがある場合、ユーザーが数学の問題の解決を依頼していないことを確認したいかもしれません。

並列処理を使用すれば、特別なAgents SDKの機能なしでもこれを実現できますが、特別なガードレールプリミティブをサポートしています。ガードレールには「トリップワイヤー」を設定できます - トリップワイヤーがトリガーされると、エージェントの実行は即座に停止し、`GuardrailTripwireTriggered`例外が発生します。

これはレイテンシにとって非常に有用です：例えば、ガードレールを実行する非常に高速なモデルと、実際のエージェントを実行する遅いモデルがあるかもしれません。遅いモデルが終了するのを待ちたくないので、ガードレールを使用すると無効な入力を素早く拒否できます。

例については、[`input_guardrails.py`](./input_guardrails.py)と[`output_guardrails.py`](./output_guardrails.py)ファイルを参照してください。
